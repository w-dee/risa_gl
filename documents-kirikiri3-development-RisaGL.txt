= RisaGL =

チケット #20

RisaGL は吉里吉里３用のプリミティブな画像演算ライブラリ。

現行のtvpglは各演算関数専用に実装がすべて書いてあるが、変形アルゴリズムが同一なのに合成アルゴリズムが違うだけで関数が分かれているなど、記述の効率性に欠ける。

これを C++ テンプレートの力を借りて効率的に記述ができるようにしたい。

MMXやSSE2などのCPU拡張命令は、コンパイラの組み込み関数としてアセンブリ言語などを使わずとも容易に記述でき、コンパイラによるインライン化や最適化で高速な動作も期待できる。

== 目指す特徴 ==

 * C++テンプレートを活用したライブラリ
 * どちらかというと精度よりは速度重視 (1bit程度の誤差はキニシナイ)
 * pure C++ によるポータブルな実装 + MMX等の拡張命令を利用した高速な実装

 * tvpglの現行の機能と同等の機能を最低限持つこと
 * 8bpp(グレースケール)および32bpp(フルカラー+アルファチャンネル)に対応すること
   * 24bpp(カラー)+8bpp(アルファ)に分離した画像はとりあえず考えなくて良いと思うが、これも視野に入れたクラス設計ができる？
 * 最低でもIA32の拡張命令(MMXなど)に対応して高速化を図ること
 * STLチックな命名規則など(?)

 * 対応コンパイラはとりあえず gcc 3.4以降に最低でも対応


== 機能の分類 ==

=== ピクセルの分類 ===
- * 8bppピクセル
- * 32bppピクセル

=== ピクセルイテレータの分類 ===
入力イテレータと出力イテレータを分ける?

- * 汎用的なシーケンシャルイテレータ (順方向にしか移動しない)
- * 64bit境界単位で動作するシーケンシャルイテレータ(CPU拡張命令用)
- * 128bit境界単位で動作するシーケンシャルイテレータ(CPU拡張命令用)
 * 変形イテレータ(特定の法則に従ってスキャンを行う; 拡大縮小やアフィン変換・透視変換などで用いる; 入力イテレータのみ)

=== 合成関数の分類 ===

 * ピクセルのコンポーネントがそれぞれ独立に演算できる合成 (例: 加算アルファ合成における透明度操作)
 * srcのアルファ値に従うが、RGBそれぞれは独立して演算できる合成 (例: 重ね合わせ先の透明度を考慮しない場合のアルファ合成)
 * srcおよびdestのアルファ値に従うが、RGBそれぞれは独立に演算できる合成 (例: 重ね合わせ先の透明度を考慮する場合のアルファ合成)
 * アルファ値は触らないが、RGBそれぞれは独立して演算できない合成 (例: HSVカラー補正)

=== 合成の入力と出力の分類 ===

入力のピクセルイテレータをいくつ取るか

 * 無項 D=const
 * 単項 D=f(U)
 * 二項 D=f(U,V)
 * 三項 D=f(U,V,W)


DとUが同じ(画素を示す)イテレータの場合も考慮しなければいけない (DとUがシーケンシャルイテレータの場合のみ)。これはたとえば画像Xに画像Yをアルファ合成するという場合にX=f(X,Y)として使うため。

=== 合成/操作関数の分類 ===


D=32bpp専用

==== 三項 ====
 * ユニバーサルトランジション用
   * Uのアルファ値を考慮しない、アルファ値を考慮する、アルファ値を加算アルファ合成としてあつかうの3種類

==== 二項 ====
- * カラーマップ (8bppの不透明度入力を元に特定の色をその不透明度で描画) (以下の2*2*4=16種類) 
-   * 65階調(文字描画用) と 256階調(通常用)
-   * opacity=255とopacity=255以外の2種類
-   * 以下の4種類
-     * Uを完全不透明であると見なし、Uのアルファ値を保存して合成
-     * Uを完全不透明であると見なし、Uのアルファ値を破壊して合成 (上のやつより高速)
? 合成先のデータは？     * Uのアルファ値をアルファ合成用のアルファ値と見なして合成
? 合成先のデータは？    * Uのアルファ値を加算アルファ合成用のアルファ値と見なして合成

- * UにVの不透明度をコピーする(Uの不透明度以外の部分はそのまま)
- * UにVの不透明度以外の部分をコピーする(Uの不透明度の部分はそのまま)
- * 8bppのVを不透明度と見なして32bppのUにコピーする(Uの不透明度以外の部分はそのまま)
 * Uに完全不透明なVを指定の不透明度で重ね合わせる
   * 以下の4種類
     * Uを完全不透明であると見なし、Uのアルファ値を保存して合成
     * Uを完全不透明であると見なし、Uのアルファ値を破壊して合成 (上のやつより高速)
     * Uをアルファ合成用画素と見なして合成
     * Uを加算アルファ合成用画素と見なして合成

 * Uから不透明度を除去して合成する(Vの不透明度が大きいほどUが透明になる) (以下の2*2*2=8種類)
   * 65階調(文字描画用) と 256階調(通常用)
   * opacity=255とopacity=255以外の2種類
   * 以下の3種類
     * Uをアルファ合成用画素と見なして合成
     * Uを加算アルファ合成用画素と見なして合成

 * アルファ合成 (以下の2*4=8種類)
   * opacity=255とopacity=255以外の2種類
   * 以下の4種類
     * Uを完全不透明であると見なし、Uのアルファ値を保存して合成
     * Uを完全不透明であると見なし、Uのアルファ値を破壊して合成 (上のやつより高速)
     * Uをアルファ合成用画素と見なして合成
     * Uを加算アルファ合成用画素と見なして合成

 * 加算アルファ合成 (以下の2*3=6種類)
   * opacity=255とopacity=255以外の2種類
   * 以下の3種類
     * Uを完全不透明であると見なし、Uのアルファ値を保存して合成
     * Uを完全不透明であると見なし、Uのアルファ値を破壊して合成 (上のやつより高速)
     * Uを加算アルファ合成用画素と見なして合成

 * 加算合成 (以下の2*2=4種類)
   * opacity=255とopacity=255以外の2種類
   * 以下の2種類
     * Uのアルファ値を保存して合成
     * Uのアルファ値を破壊して合成(上のやつより高速)

 * 減算合成 (加算合成と同じ4種類)

 * 乗算合成 (加算合成と同じ4種類)

 * 覆い焼き合成 (加算合成と同じ4種類)

 * 比較(暗)合成 (加算合成と同じ4種類)

 * 比較(明)合成 (加算合成と同じ4種類)

 * スクリーン合成 (加算合成と同じ4種類)

 * PS互換アルファ合成 (加算合成と同じ4種類)

 * PS互換加算合成 (加算合成と同じ4種類)

 * PS互換減算合成 (加算合成と同じ4種類)

 * PS互換乗算合成 (加算合成と同じ4種類)

 * PS互換スクリーン合成 (加算合成と同じ4種類)

 * PS互換オーバーレイ合成 (加算合成と同じ4種類)

 * PS互換ハードライト合成 (加算合成と同じ4種類)

 * PS互換ソフトライト合成 (加算合成と同じ4種類)

 * PS互換覆い焼きカラー合成 (加算合成と同じ4種類)

 * PS5互換覆い焼きカラー合成 (加算合成と同じ4種類)

 * PS互換焼き込みカラー合成 (加算合成と同じ4種類)

 * PS互換比較(明)合成 (加算合成と同じ4種類)

 * PS互換比較(暗)合成 (加算合成と同じ4種類)

 * PS互換差合成 (加算合成と同じ4種類)

 * PS5互換差の絶対値合成 (加算合成と同じ4種類)

 * PS互換除外合成 (加算合成と同じ4種類)

==== 単項 ====
 * マット合成(特定の色をUの下敷きにする)
   * アルファ合成、加算α合成の２種類
 * 加算アルファ合成用画像をアルファ合成用画像に変換
 * アルファ合成用画像を加算アルファ合成用画像に変換
 * Uの不透明度を255にして返す(不透明度を最大にする)
 * Uに固定色を固定濃度で重ね合わせる
   * 以下の4種類
     * Uを完全不透明であると見なし、Uのアルファ値を保存して合成
     * Uを完全不透明であると見なし、Uのアルファ値を破壊して合成 (上のやつより高速)
     * Uをアルファ合成用画素と見なして合成
     * Uを加算アルファ合成用画素と見なして合成
 * Uの不透明度を操作する
   * 以下の3種類
     * Uを完全不透明であると見なし、Uのアルファ値を設定
     * Uをアルファ合成用画素と見なして操作
     * Uを加算アルファ合成用画素と見なして操作
 * Uの指定色を不透明度0にする
 * U の不透明度を指定不透明度で塗りつぶす(Uの不透明度以外の部分はそのまま)
 * U の不透明度以外の部分を指定色で塗りつぶす(Uの不透明度の部分はそのまま)
 * U をグレースケールに変換
 * U をガンマ補正する(以下の2種類)
   * 完全不透明あるいはアルファ合成用
   * 加算アルファ合成用

===== 無項 =====

 * 特定のARGBで塗りつぶす



===== そのほか =====

 * box blur
   * Uを完全不透明であると見なす
   * Uをアルファ合成用の画素であると見なす
   * Uを加算アルファ合成用の画素であると見なす
 * 文字用ガウシアンぼかし(D=8bpp専用)


=== ピクセルマージの分類 ===

指定の2点あるいは4点を指定の濃度で混合する方法

 * アルファ値考慮無し
 * アルファ合成用の画素として扱う(すごい重い)
 * 加算アルファ合成用の画素として扱う

=== 変形の分類 ===

 * 変形無し(出力=入力=シーケンシャルイテレータ)
 * 拡大・縮小(出力=シーケンシャルイテレータ、入力=変形イテレータ)
   * nearest
   * bi-linear
 * アフィン変換(出力=シーケンシャルイテレータ、入力=変形イテレータ)
   * nearest
   * bi-linear
 * 透視変換(出力=シーケンシャルイテレータ、入力=変形イテレータ)
   * nearest
   * bi-linear
 * そのほか、変形トランジション用の何かとか

== 課題 ==

 * これらを実現できる柔軟なクラス設計が必要
 * イテレータの種類は合成関数と変形処理によって決めなければならない
 * 合成関数にはMMX,SSE2などのバージョンがあると思うが、このために使用するイテレータを変えなければならない時がある(?)
 * CPU拡張命令はシビアな要求が多い(例: ピクセルは4ピクセルごとに処理すると速い, アライメントされていないメモリアドレスにアクセスするとクラッシュする等)。これらをどううまく扱うか(少なくとも8bppの画像は8bit境界に、32bppの画像は32bit境界にアラインメントされていると見なして良い)


